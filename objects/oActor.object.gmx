<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>state = "idle";

army = BLUE_ARMY;

gridX = 0;
gridY = 0;

name = "oActorErrorNAME";

class = "oActorErrorCLASS";
advClass = "ErrorADVClass";

race = "oActorErrorRACE";

//character stats --------------------------------------

level = 1;

//Primary stats ---------------------------------------------
strMod = 0;
endMod = 0;
vitMod = 0;
dexMod = 0;
intMod = 0;
wisMod = 0;

//HP, AP(Mana/Energy) and status
maxHitPoints = 10 + vitMod + ((level - 1) * (3 + vitMod));
hitPoints = maxHitPoints;

maxAbilityPoints = 10 + round((intMod/2 + wisMod/2)) + ((level - 1) * (3 + round((intMod/2 + wisMod/2))));
abilityPoints = maxAbilityPoints;

status = "normal";

//Secondary stats --------------------------------------------

//Physical stats
attack = strMod;
rangedAttack = dexMod;
defense = endMod;
dodgeChance = 15 + dexMod;
critChance = 5 + dexMod;
accuracy = 80 + dexMod;

//Magic stats
magicAttack = intMod;
magicDefense = wisMod;
magicCritChance = 5 + intMod;
magicHeal = wisMod;

//Default attack determining variables
attackType = "melee";
defaultProjectile = oArrow;
//physical or magical
damageType = "physical";
//default attackRange
attackRange = 15 * NODE_SIZE;

//Resistances -- weak to elements make resistance negative
resistanceMap = ds_map_create();
ds_map_add(resistanceMap, "fire", 0);
ds_map_add(resistanceMap, "ice", 0);
ds_map_add(resistanceMap, "earth", 0);
ds_map_add(resistanceMap, "lightning", 0);
ds_map_add(resistanceMap, "light", 0);
ds_map_add(resistanceMap, "dark", 0);
ds_map_add(resistanceMap, "psychic", wisMod);
ds_map_add(resistanceMap, "status", 0);
ds_map_add(resistanceMap, "fury", 50);

//elemental damage modifiers
magicDamageMap = ds_map_create();
ds_map_add(magicDamageMap, "physical", 0);
ds_map_add(magicDamageMap, "fire", 0);
ds_map_add(magicDamageMap, "ice", 0);
ds_map_add(magicDamageMap, "earth", 0);
ds_map_add(magicDamageMap, "lightning", 0);
ds_map_add(magicDamageMap, "light", 0);
ds_map_add(magicDamageMap, "dark", 0);
ds_map_add(magicDamageMap, "status", 0);

//buffs------------------------------------------------
blessed = 0;
//debuffs----------------------------------------------
poisoned = 0;

//spell and ability variables
readiedAction = "error";
targetingType = "error";
abilityRange = 0;

firstLevelSlotMax = 0;
firstLevelSlot = 0;

//move and action variables ----------------------------------------
move = 6;
actions = 2;
canAct = false;

//Turn Order variables
initiative = dexMod;
initRoll = 0;

//variables related to buttons
actions[0] = "move";
actions[1] = "attack";
actions[2] = "ability";
actions[3] = "item";
actions[4] = "end";

//NO NEED TO MODIFY IN CHILDREN---------------------------------------------------

//Attack target and animation variables
attackTarget = noone;
actionTimer = 0;

//variables related to pathing ---------------------------------------------------
movementPath = path_add();
path_set_kind(movementPath, 2);
path_set_closed(movementPath, false);

endPath = "idle";

moveSpeed = 2;

//Movement animation-------------------------------------------------------------
spriteIdle = sTestTavitIdle;
walkRight = sTestTavitR;
walkLeft = sTestTavitL;
walkUp = sTestTavitU;
walkDown = sTestD;
spriteDead = sTestTavitDead;
spriteDying = sTestTavitDying;

image_speed = 2/room_speed;

//variables related to effects -------------------------------------------------
shake = 0;
shakeMag = 0;




































</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(xprevious&gt;x){sprite_index=walkLeft}; 
if(xprevious&lt;x){sprite_index=walkRight}; 
if(yprevious&gt;y){sprite_index=walkUp}; 
if(yprevious&lt;y){sprite_index=walkDown};

if(xprevious==x&amp;&amp;yprevious==y &amp;&amp; state!="dying" &amp;&amp; state!="dead"){sprite_index=spriteIdle};




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shake -= 1;

//If I die
if(hitPoints &lt;= 0 &amp;&amp; state != "dead" &amp;&amp; shake == 0) {
    hitPoints = 0;
    state = "dying";
    //If it's my turn
    if(oGame.currentActor = id) {
        oGame.currentActor = noone;
        oCursor.selectedActor = noone;
    }
}

switch(state) {
    case "initialize turn":
        actionTimer -= 1;
        if(actionTimer &lt;=0) {
        
            //Checking for buffs
            if(blessed &gt; oGame.roundCounter) {
                with(instance_create(x, y, oBless)) {
                    target = other;
                }
            } else {
                blessed = 0;
            }
            
            movement_range(id);
            
            //Update Action Menu
            
            get_attack_range(id);
            
            oCursor.selectedActor = id;
            
            state = "idle";
        }
        
        break;
    
    case "idle":
        sprite_index = spriteIdle;
    break;

    case "begin path":
        //begin moving along path
        path_start(movementPath, moveSpeed, 0, true);
        
        state = "moving";
        break;

    //before attack animation goes here
    case "begin attack":
        actionTimer -= 1;
        if(actionTimer &lt;=0) {
            state = "attack";
        }
    
        break;

    case "attack":
        attackStatus = determine_attack_status();

        tempDamage = determine_physical_damage(attackStatus);
        
        switch(attackType) {
                        
            case "ranged":                
                draw_projectile(defaultProjectile, attackTarget, attackStatus, tempDamage);
                
                attackTarget.hitPoints -= tempDamage;
                
                state = "end attack";
                
                actionTimer = 40;
                
                break;
                
            case "melee":
                draw_damage_animation(attackStatus, attackTarget, tempDamage);
                
                attackTarget.hitPoints -= tempDamage;
                
                state = "end attack";
                
                actionTimer = 20;                
            
                break;
        }
        
        break;
        
    
    case "end attack":
        actionTimer -= 1;
        
        if(actionTimer &lt;= 0) {
            if(actions &gt; 0) {
                oCursor.selectedActor = id;
                
                movement_range(id);
            } else {
                oGame.currentActor = noone;
            }
            
            state = "idle";
        }
        
        break;
        
    case "begin action":
        wipe_nodes();
        ability_targeting(id);
        
        break;        
             
    case "perform action":        
        perform_action(id, readiedAction);
        
        wipe_nodes();
        break;
        
    case "end action":
        actionTimer -= 1;
        
        if(actionTimer &lt;= 0) {
            state = "idle";
            
            if(actions &gt; 0) {
                movement_range(id);
            } else {
                state = "idle";
                oCursor.selectedActor = noone;
                oGame.currentActor = noone;
            }
        }
        break;
    
    case "end turn":
        actionTimer -= 1;
        if(actionTimer &lt;= 0) {
            oCursor.selectedActor = noone;
            oGame.currentActor = noone;
            state = "idle";
        }
        
        break;

    case "dying":
        sprite_index = spriteDying;
    break;    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//clear path
path_clear_points(movementPath);

//Update position
global.map[gridX, gridY].occupant = id;

state = "idle";
xprevious = x;
yprevious = y;
sprite_index = spriteIdle;

if(actions &gt; 0) {
    oCursor.selectedActor = id;
//DEBUGGING REMOVE LATER
//    show_message(map[gridX, gridY].occupant.name);
//    show_message("Actor X = " + string(gridX));
    movement_range(id);
    
    if(canAct) {
        get_attack_range(id);
    }
    
} else {
    oGame.currentActor = noone;
}







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(state == "dying") {
    sprite_index = spriteDead;
    state = "dead";
}

if(state == "idle") {
    sprite_index = spriteIdle;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if cursor is hovering over different node than actor
if(oCursor.selectedActor == id &amp;&amp; oCursor.hoverNode != noone) {
    tempNode = oCursor.hoverNode;
    
    if(tempNode.moveNode) {
        current = tempNode;
        
        //step through every node in the chain, parent to parent, until we reach actor's node.
        while(current.parent != noone) {
            draw_line_width_colour(current.x + NODE_SIZE/2, current.y +NODE_SIZE/2, current.parent.x + NODE_SIZE/2, current.parent.y + NODE_SIZE/2, 4, c_blue, c_blue);
            
            current = current.parent;
            
        }
        
    }
    
    if(tempNode.attackNode) {
        switch(attackType) {
            case "ranged":
                draw_line_width_colour(x + NODE_SIZE/2, y + NODE_SIZE/2, tempNode.x + NODE_SIZE/2, tempNode.y + NODE_SIZE/2, 4, c_purple, c_purple);
                break;
        
        }
        
    }
    
}

if(shake &gt; 0) {
    draw_sprite_ext(sprite_index, 2, x + irandom_range(-shakeMag, shakeMag), y + irandom_range(-shakeMag, shakeMag), 1, 1, 0, c_white, 1);
} else {

    draw_self();

}























</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
