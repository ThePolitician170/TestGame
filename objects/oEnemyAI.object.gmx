<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shake -= 1;

//If I die
if(hitPoints &lt;= 0 &amp;&amp; state != "dead" &amp;&amp; shake == 0) {
    hitPoints = 0;
    state = "dying";
    //If it's my turn
    if(oGame.currentActor = id) {
        oGame.currentActor = noone;
        oCursor.selectedActor = noone;
    }
}

switch(state) {
    case "initialize turn":
        actionTimer -= 1;
        if(actionTimer &lt;=0) {
        
            //Checking for buffs
            if(blessed &gt; oGame.roundCounter) {
                with(instance_create(x, y, oBless)) {
                    target = other;
                }
            } else {
                blessed = 0;
            }
                   
            state = "find target";
        }
        
        break;
        
    case "find target":
        attackTarget = noone;
        
        node = global.map[gridX, gridY];
        
        targetList = ds_list_create();
        
        for(ii = 0; ii &lt; ds_list_size(node.neighbors); ii += 1) {
            neighbor = ds_list_find_value(node.neighbors, ii);
            
            if(neighbor.occupant != noone) {
                if(neighbor.occupant.army != army) {
                   ds_list_add(targetList, neighbor.occupant);
                }
            }
        }
        
        if(ds_list_size(targetList)) &gt; 0 {
            attackTarget = ds_list_find_value(targetList, irandom_range(0, ds_list_size(targetList) - 1));
        }
        
        ds_list_destroy(targetList);
        
        if(attackTarget != noone) {
            state = "begin attack";
            flash = "true";
            actionTimer = 10;
        } else {
            state = "find move node";
        }     
           
        break;
        
    case "find move node":
        heroList = ds_priority_create();
        
        with(oActor) {
            if(army != other.army) {
                ds_priority_add(other.heroList, id, point_distance(x, y, other.x, other.y));
            }
        }
        
        closestNode = noone;
        
        while(closestNode == noone) {
            targetHero = ds_priority_delete_min(heroList);
            
            targetNode = global.map[targetHero.gridX, targetHero.gridY];
            
            for(ii = 0; ii &lt; ds_list_size(targetNode.neighbors); ii += 1) {
                currentNode = ds_list_find_value(targetNode.neighbors, ii);
                if(currentNode.occupant == noone &amp;&amp; currentNode.passable) {
                    closestNode = currentNode;
                }
                
            }
            
            if(ds_priority_size(heroList) &lt;= 0) {
                targetHero = noone;
                state = "idle";
                break;
            }
        
        }
        
        ds_priority_destroy(heroList);
        
        if(targetHero != noone) {
            ai_movement(global.map[gridX, gridY], closestNode);
            
            while(closestNode.G &gt; move * actions) {
                closestNode = closestNode.parent;
            }
            
            create_move_path(id, closestNode);
            
            global.map[gridX, gridY].occupant = noone;
            
            gridX = closestNode.gridX;
            gridY = closestNode.gridY;
            
            closestNode.occupant = id;
            
            state = "begin path";
            
            if(closestNode.G &gt; move) {
                actions -= 2;
            } else {
                actions -= 1; 
            }
        }
        
        wipe_nodes();
    
        break;
        
    case "idle":
        sprite_index = spriteIdle;
    break;
        
    case "begin path":
        path_start(movementPath, moveSpeed, 0, true);
        
        state = "moving";
        
        break;
        
    //before attack animation goes here
    case "begin attack":
        actionTimer -= 1;
        if(actionTimer &lt;=0) {
            state = "attack";
        }
    
        break;

    case "attack":
        attackStatus = determine_attack_status();

        tempDamage = determine_physical_damage(attackStatus);
        
        switch(attackType) {
                        
            case "ranged":                
                draw_projectile(defaultProjectile, attackTarget, attackStatus, tempDamage);
                
                attackTarget.hitPoints -= tempDamage;
                
                state = "end attack";
                
                actionTimer = 30;
                
                break;
                
            case "melee":
                draw_damage_animation(attackStatus, attackTarget, tempDamage);
                
                attackTarget.hitPoints -= tempDamage;
                
                state = "end attack";
                
                actionTimer = 10;                
            
                break;
        }
        
        break;
        
    
    case "end attack":
        actionTimer -= 1;
        
        if(actionTimer &lt;= 0) {
            oGame.currentActor = noone;
            flash = "false";
            color = c_white;
            state = "idle";
        }
        
        break;
        
    case "dying":
        sprite_index = spriteDying;
    break;
        
        
}











































</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear path and set state
path_clear_points(movementPath);

if(actions &gt; 0) {
    state = "find target";
    
} else {
    state = "idle";
    sprite_index = spriteIdle;
    oGame.currentActor = noone;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
